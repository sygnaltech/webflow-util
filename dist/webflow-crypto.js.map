{
  "version": 3,
  "sources": ["../src/webflow-crypto.ts"],
  "sourcesContent": ["\n/*\n * webflow-crypto\n * \n * Sygnal Technology Group\n * http://sygnal.com\n * \n * Hashing & Cryptographic Utilities\n */\n\n// xxhash64 implementation\n// Copyright 2019-2020, Yann Collet <github.com/Cyan4973>\n// Copyright 2016, Pierre Curto <github.com/pierrec>\n// Copyright 2019, Daniel Lo Nigro <github.com/Daniel15>\n// Copyright 2021, intrnl <github.com/intrnl> \n// https://codeberg.org/intrnl/js-xxhash64/src/branch/trunk/src/index.js \n\n\nconst PRIME64_1 = 11400714785074694791n;\nconst PRIME64_2 = 14029467366897019727n;\nconst PRIME64_3 = 1609587929392839161n;\nconst PRIME64_4 = 9650029242287828579n;\nconst PRIME64_5 = 2870177450012600261n;\n\nconst BITS = 64n;\nconst BITMASK = 2n ** BITS - 1n;\n\nconst encoder = new TextEncoder();\n\nfunction bitsToBigInt (a00, a16, a32, a48) {\n\treturn (\n\t\t(BigInt(a00)) |\n\t\t(BigInt(a16) << 16n) |\n\t\t(BigInt(a32) << 32n) |\n\t\t(BigInt(a48) << 48n)\n\t);\n}\n\nfunction memoryToBigInt(memory, offset) {\n\treturn (\n\t\t(BigInt(memory[offset])) |\n\t\t(BigInt(memory[offset+1]) << 8n) |\n\t\t(BigInt(memory[offset+2]) << 16n) |\n\t\t(BigInt(memory[offset+3]) << 24n) |\n\t\t(BigInt(memory[offset+4]) << 32n) |\n\t\t(BigInt(memory[offset+5]) << 40n) |\n\t\t(BigInt(memory[offset+6]) << 48n) |\n\t\t(BigInt(memory[offset+7]) << 56n)\n\t);\n}\n\nfunction rotl (value, rotation) {\n\treturn (\n\t\t((value << rotation) & BITMASK) |\n\t\t(value >> (BITS - rotation))\n\t);\n}\n\nfunction trunc (value) {\n\treturn BigInt.asUintN(64, value);\n}\n\n\nexport class XXH64 {\n\t#seed;\n\t#v1;\n\t#v2;\n\t#v3;\n\t#v4;\n\n\t#memory;\n\n\t#len;\n\t#memsize;\n\n\tconstructor (seed = 0) {\n\t\tthis.reset(seed);\n\t}\n\n\treset (seed = this.#seed) {\n\t\tthis.#seed = BigInt.asUintN(32, BigInt(seed));\n\t\tthis.#v1 = trunc(this.#seed + PRIME64_1 + PRIME64_2);\n\t\tthis.#v2 = trunc(this.#seed + PRIME64_2);\n\t\tthis.#v3 = this.#seed;\n\t\tthis.#v4 = trunc(this.#seed - PRIME64_1);\n\n\t\tthis.#memory = null;\n\n\t\tthis.#len = 0;\n\t\tthis.#memsize = 0;\n\n\t\treturn this;\n\t}\n\n\tupdate (input) {\n\t\tif (typeof input === 'string') {\n\t\t\tinput = encoder.encode(input);\n\t\t}\n\n\t\tlet p = 0;\n\t\tlet len = input.length;\n\t\tlet bEnd = p + len;\n\n\t\tif (len === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.#len += len;\n\n\t\tif (this.#memsize === 0) {\n\t\t\tthis.#memory = new Uint8Array(32);\n\t\t}\n\n\t\tif (this.#memsize + len < 32) {\n\t\t\tthis.#memory.set(input.subarray(0, len), this.#memsize);\n\n\t\t\tthis.#memsize += len;\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.#memsize > 0) {\n\t\t\tthis.#memory.set(input.subarray(0, 32 - this.#memsize), this.#memsize);\n\n\t\t\tlet p64 = 0;\n\t\t\tlet other;\n\n\t\t\tother = memoryToBigInt(this.#memory, p64);\n\t\t\tthis.#v1 = trunc(rotl(trunc(this.#v1 + other * PRIME64_2), 31n) * PRIME64_1);\n\n\t\t\tp64 += 8\n\t\t\tother = memoryToBigInt(this.memory, p64)\n\t\t\tthis.#v2 = trunc(rotl(trunc(this.#v2 + other * PRIME64_2), 31n) * PRIME64_1);\n\n\t\t\tp64 += 8\n\t\t\tother = memoryToBigInt(this.memory, p64)\n\t\t\tthis.#v3 = trunc(rotl(trunc(this.#v3 + other * PRIME64_2), 31n) * PRIME64_1);\n\n\t\t\tp64 += 8\n\t\t\tother = memoryToBigInt(this.memory, p64)\n\t\t\tthis.#v4 = trunc(rotl(trunc(this.#v4 + other * PRIME64_2), 31n) * PRIME64_1);\n\n\t\t\tp += 32 - this.#memsize;\n\t\t\tthis.#memsize = 0;\n\t\t}\n\n\t\tif (p <= bEnd - 32) {\n\t\t\tconst limit = bEnd - 32;\n\n\t\t\tdo {\n\t\t\t\tlet other;\n\n\t\t\t\tother = memoryToBigInt(input, p)\n\t\t\t\tthis.#v1 = trunc(rotl(trunc(this.#v1 + other * PRIME64_2), 31n) * PRIME64_1);\n\t\t\t\tp += 8\n\n\t\t\t\tother = memoryToBigInt(input, p)\n\t\t\t\tthis.#v2 = trunc(rotl(trunc(this.#v2 + other * PRIME64_2), 31n) * PRIME64_1);\n\t\t\t\tp += 8\n\n\t\t\t\tother = memoryToBigInt(input, p)\n\t\t\t\tthis.#v3 = trunc(rotl(trunc(this.#v3 + other * PRIME64_2), 31n) * PRIME64_1);\n\t\t\t\tp += 8\n\n\t\t\t\tother = memoryToBigInt(input, p)\n\t\t\t\tthis.#v4 = trunc(rotl(trunc(this.#v4 + other * PRIME64_2), 31n) * PRIME64_1);\n\t\t\t\tp += 8\n\t\t\t} while (p <= limit)\n\t\t}\n\n\t\tif (p < bEnd) {\n\t\t\tthis.#memory.set(input.subarray(p, bEnd), this.#memsize);\n\t\t\tthis.#memsize = bEnd - p;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdigest () {\n\t\tlet input = this.#memory;\n\n\t\tlet bEnd = this.#memsize;\n\t\tlet p = 0;\n\t\tlet h64 = 0n;\n\t\tlet h = 0n;\n\t\tlet u = 0n;\n\n\t\tif (this.#len >= 32) {\n\t\t\th64 = rotl(this.#v1, 1n) + rotl(this.#v2, 7n) + rotl(this.#v3, 12n) + rotl(this.#v4, 18n);\n\n\t\t\th64 = trunc(h64 ^ (rotl(trunc(this.#v1 * PRIME64_2), 31n) * PRIME64_1));\n\t\t\th64 = trunc(h64 * PRIME64_1 + PRIME64_4);\n\n\t\t\th64 = trunc(h64 ^ (rotl(trunc(this.#v2 * PRIME64_2), 31n) * PRIME64_1));\n\t\t\th64 = trunc(h64 * PRIME64_1 + PRIME64_4);\n\n\t\t\th64 = trunc(h64 ^ (rotl(trunc(this.#v3 * PRIME64_2), 31n) * PRIME64_1));\n\t\t\th64 = trunc(h64 * PRIME64_1 + PRIME64_4);\n\n\t\t\th64 = trunc(h64 ^ (rotl(trunc(this.#v4 * PRIME64_2), 31n) * PRIME64_1));\n\t\t\th64 = trunc(h64 * PRIME64_1 + PRIME64_4);\n\t\t}\n\t\telse {\n\t\t\th64 = trunc(this.#seed + PRIME64_5);\n\t\t}\n\n\t\th64 += BigInt(this.#len);\n\n\t\twhile (p <= bEnd - 8) {\n\t\t\tu = memoryToBigInt(input, p);\n\t\t\tu = trunc(rotl(trunc(u * PRIME64_2), 31n) * PRIME64_1);\n\n\t\t\th64 = trunc((rotl(h64 ^ u, 27n) * PRIME64_1) + PRIME64_4);\n\t\t\tp += 8;\n\t\t}\n\n\t\tif (p + 4 <= bEnd) {\n\t\t\tu = bitsToBigInt((input[p+1] << 8) | input[p], (input[p+3] << 8) | input[p+2], 0, 0);\n\t\t\th64 = trunc((rotl(h64 ^ trunc((u * PRIME64_1)), 23n) * PRIME64_2) + PRIME64_3);\n\t\t\tp += 4;\n\t\t}\n\n\t\twhile (p < bEnd) {\n\t\t\tu = bitsToBigInt(input[p++], 0, 0, 0);\n\t\t\th64 = trunc(rotl(h64 ^ trunc(u * PRIME64_5), 11n) * PRIME64_1);\n\t\t}\n\n\t\th = trunc(h64 >> 33n);\n\t\th64 = trunc((h64 ^ h) * PRIME64_2);\n\n\t\th = trunc(h64 >> 29n);\n\t\th64 = trunc((h64 ^ h) * PRIME64_3);\n\n\t\th = trunc(h64 >> 32n);\n\t\th64 = trunc(h64 ^ h);\n\n\t\treturn h64;\n\t}\n\n    static hash (input, seed = 0) {\n        return new XXH64(seed).update(input).digest()\n            .toString(16); // Hex\n    }    \n\n}\n\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import \n// https://www.npmjs.com/package/blueimp-md5-es6\n// https://github.com/pvorb/node-md5/issues/52 \n// https://code.tutsplus.com/tutorials/how-to-hash-and-decrypt-with-md5-in-javascript--cms-38297\n// import CryptoJS from ''; \n\n// import * as md5 from 'https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js';\n\n// const toUtf8_1 = require(\"https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/toUtf8.js\");\nconst PRIME32_1 = 2654435761;\nconst PRIME32_2 = 2246822519;\nconst PRIME32_3 = 3266489917;\nconst PRIME32_4 = 668265263;\nconst PRIME32_5 = 374761393;\n\n// https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/toUtf8.js \n\nfunction toUtf8_1(text) {\n    const bytes = [];\n    const w = new Array(4);\n    const h = [0x00, 0xc0, 0xe0, 0xf0];\n    const m = [0x7f, 0x3f, 0x3f, 0x3f];\n    const p = [0x00, 0x80, 0x80, 0x80];\n    for (const char of text) {\n        const b = w;\n        const cp = char.codePointAt(0);\n        const n = 0\n            - ((-(cp & 0xffffff80) >> 31))\n            - ((-(cp & 0xfffff800) >> 31))\n            - ((-(cp & 0xffff0000) >> 31));\n        const z = m[n];\n        const y = p[n];\n        b[3] = y | (cp & z);\n        b[2] = y | ((cp >>> 6) & z);\n        b[1] = y | ((cp >>> 12) & z);\n        b[0] = y | ((cp >>> 18) & z);\n        const s = 3 - n;\n        b[s] |= h[n];\n        Array.prototype.push.apply(bytes, b.slice(s));\n    }\n    return new Uint8Array(bytes);\n}\n\n\n\nexport class XXH32 {\n\n    /**\n     *\n     * @param buffer - byte array or string\n     * @param seed - optional seed (32-bit unsigned);\n     */\n    // https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/xxHash32.js\n\n    static hash(buffer, seed = 0) {\n        buffer = typeof buffer === 'string' ? toUtf8_1(buffer) : buffer;\n        const b = buffer;\n        /*\n            Step 1. Initialize internal accumulators\n            Each accumulator gets an initial value based on optional seed input. Since the seed is optional, it can be 0.\n\n            ```\n                u32 acc1 = seed + PRIME32_1 + PRIME32_2;\n                u32 acc2 = seed + PRIME32_2;\n                u32 acc3 = seed + 0;\n                u32 acc4 = seed - PRIME32_1;\n            ```\n            Special case : input is less than 16 bytes\n            When input is too small (< 16 bytes), the algorithm will not process any stripe. Consequently, it will not\n            make use of parallel accumulators.\n\n            In which case, a simplified initialization is performed, using a single accumulator :\n\n            u32 acc  = seed + PRIME32_5;\n            The algorithm then proceeds directly to step 4.\n        */\n        let acc = (seed + PRIME32_5) & 0xffffffff;\n        let offset = 0;\n        if (b.length >= 16) {\n            const accN = [\n                (seed + PRIME32_1 + PRIME32_2) & 0xffffffff,\n                (seed + PRIME32_2) & 0xffffffff,\n                (seed + 0) & 0xffffffff,\n                (seed - PRIME32_1) & 0xffffffff,\n            ];\n            /*\n                Step 2. Process stripes\n                A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 lanes, of 4 bytes each.\n                The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.\n\n                Each lane read its associated 32-bit value using little-endian convention.\n\n                For each {lane, accumulator}, the update process is called a round, and applies the following formula :\n\n                ```\n                accN = accN + (laneN * PRIME32_2);\n                accN = accN <<< 13;\n                accN = accN * PRIME32_1;\n                ```\n\n                This shuffles the bits so that any bit from input lane impacts several bits in output accumulator.\n                All operations are performed modulo 2^32.\n\n                Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume\n                the whole input, except the last remaining bytes which cannot form a stripe (< 16 bytes). When that\n                happens, move to step 3.\n            */\n            const b = buffer;\n            const limit = b.length - 16;\n            let lane = 0;\n            for (offset = 0; (offset & 0xfffffff0) <= limit; offset += 4) {\n                const i = offset;\n                const laneN0 = b[i + 0] + (b[i + 1] << 8);\n                const laneN1 = b[i + 2] + (b[i + 3] << 8);\n                const laneNP = laneN0 * PRIME32_2 + (laneN1 * PRIME32_2 << 16);\n                let acc = ((accN[lane] + laneNP) & 0xffffffff);\n                acc = (acc << 13) | (acc >>> 19);\n                const acc0 = acc & 0xffff;\n                const acc1 = acc >>> 16;\n                accN[lane] = (acc0 * PRIME32_1 + (acc1 * PRIME32_1 << 16)) & 0xffffffff;\n                lane = (lane + 1) & 0x3;\n            }\n            /*\n                Step 3. Accumulator convergence\n                All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator\n                of same width (32-bit). The associated formula is as follows :\n\n                ```\n                acc = (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18);\n                ```\n            */\n            acc = (((accN[0] << 1) | (accN[0] >>> 31))\n                + ((accN[1] << 7) | (accN[1] >>> 25))\n                + ((accN[2] << 12) | (accN[2] >>> 20))\n                + ((accN[3] << 18) | (accN[3] >>> 14))) & 0xffffffff;\n        }\n        /*\n            Step 4. Add input length\n            The input total length is presumed known at this stage. This step is just about adding the length to\n            accumulator, so that it participates to final mixing.\n\n            ```\n            acc = acc + (u32)inputLength;\n            ```\n        */\n        acc = (acc + buffer.length) & 0xffffffff;\n        /*\n            Step 5. Consume remaining input\n            There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according\n            to following pseudo-code :\n            ```\n            while (remainingLength >= 4) {\n                lane = read_32bit_little_endian(input_ptr);\n                acc = acc + lane * PRIME32_3;\n                acc = (acc <<< 17) * PRIME32_4;\n                input_ptr += 4; remainingLength -= 4;\n            }\n            ```\n            This process ensures that all input bytes are present in the final mix.\n        */\n        let limit = buffer.length - 4;\n        for (; offset <= limit; offset += 4) {\n            const i = offset;\n            const laneN0 = b[i + 0] + (b[i + 1] << 8);\n            const laneN1 = b[i + 2] + (b[i + 3] << 8);\n            const laneP = laneN0 * PRIME32_3 + (laneN1 * PRIME32_3 << 16);\n            acc = ((acc + laneP) & 0xffffffff);\n            acc = (acc << 17) | (acc >>> 15);\n            acc = (((acc & 0xffff) * PRIME32_4) + (((acc >>> 16) * PRIME32_4) << 16)) & 0xffffffff;\n        }\n        /*\n            ```\n            while (remainingLength >= 1) {\n                lane = read_byte(input_ptr);\n                acc = acc + lane * PRIME32_5;\n                acc = (acc <<< 11) * PRIME32_1;\n                input_ptr += 1; remainingLength -= 1;\n            }\n            ```\n        */\n        for (; offset < b.length; ++offset) {\n            const lane = b[offset];\n            acc = acc + lane * PRIME32_5;\n            acc = (acc << 11) | (acc >>> 21);\n            acc = (((acc & 0xffff) * PRIME32_1) + (((acc >>> 16) * PRIME32_1) << 16)) & 0xffffffff;\n        }\n        /*\n            Step 6. Final mix (avalanche)\n            The final mix ensures that all input bits have a chance to impact any bit in the output digest,\n            resulting in an unbiased distribution. This is also called avalanche effect.\n            ```\n            acc = acc xor (acc >> 15);\n            acc = acc * PRIME32_2;\n            acc = acc xor (acc >> 13);\n            acc = acc * PRIME32_3;\n            acc = acc xor (acc >> 16);\n            ```\n        */\n        acc = acc ^ (acc >>> 15);\n        acc = ((acc & 0xffff) * PRIME32_2 & 0xffffffff) + ((acc >>> 16) * PRIME32_2 << 16);\n        acc = acc ^ (acc >>> 13);\n        acc = ((acc & 0xffff) * PRIME32_3 & 0xffffffff) + ((acc >>> 16) * PRIME32_3 << 16);\n        acc = acc ^ (acc >>> 16);\n        // turn any negatives back into a positive number;\n        return acc < 0 ? acc + 4294967296 : acc;\n    }\n\n}\n\n//https://cdnjs.com/libraries/crypto-js\n\n// https://cryptojs.gitbook.io/docs/ \n// https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/md5.min.js \n// https://stackoverflow.com/questions/56280825/crypto-js-module-is-imported-but-does-not-work-as-expected \n// import \"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/core.min.js\";\n//import * as CryptoJS from \"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js\"\n//  import HmacMD5 from \"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/hmac-md5.min.js\";\n\n// import * as CryptoJS from \"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/md5.js\"; \n\n// import * as XXH from \"https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/xxHash32.js\";\n//import * as xx from \"https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/index.js\"; \n// import { xxHash32 } from \"https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/index.js\";\n// https://cdn.jsdelivr.net/npm/js-xxhash@1.0.4/dist/index.js\n\n// https://github.com/bryc/code/blob/master/jshash/hashes/murmurhash3.js\nfunction MurmurHash3(key, seed = 0) {\n    var k, p1 = 3432918353, p2 = 461845907, h = seed | 0;\n\n    for(var i = 0, b = key.length & -4; i < b; i += 4) {\n        k = key[i+3] << 24 | key[i+2] << 16 | key[i+1] << 8 | key[i];\n        k = Math.imul(k, p1); k = k << 15 | k >>> 17;\n        h ^= Math.imul(k, p2); h = h << 13 | h >>> 19;\n        h = Math.imul(h, 5) + 3864292196 | 0; // |0 = prevent float\n    }\n\n    k = 0;\n    switch (key.length & 3) {\n        case 3: k ^= key[i+2] << 16;\n        case 2: k ^= key[i+1] << 8;\n        case 1: k ^= key[i];\n                k = Math.imul(k, p1); k = k << 15 | k >>> 17;\n                h ^= Math.imul(k, p2);\n    }\n\n    h ^= key.length;\n\n    h ^= h >>> 16; h = Math.imul(h, 2246822507);\n    h ^= h >>> 13; h = Math.imul(h, 3266489909);\n    h ^= h >>> 16;\n\n    return h >>> 0;\n}"],
  "mappings": "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",
  "names": ["b", "limit", "acc"]
}
