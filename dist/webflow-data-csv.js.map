{
  "version": 3,
  "sources": ["../src/webflow-data-csv.ts"],
  "sourcesContent": ["\n// Sygnal Technology Group\n// http://sygnal.com\n\n/* ESM adapted from\n * jQuery-csv (jQuery Plugin) by Evan Plaice\n * \n * - jQuery use removed\n * - redesigned as an ESM\n * \n * Original jQuery source notices;\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Original jQuery version copyrighted 2012 by Evan Plaice.\n */\n\nRegExp.escape = function (s) {\n    return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n};\n\nvar defaults = {\n    separator: ',',\n    delimiter: '\"',\n    headers: true\n};\n\nvar castToScalar = function (value, state) {\n    const hasDot = /\\./\n    if (isNaN(value)) {\n        return value\n    } else {\n        if (hasDot.test(value)) {\n            return parseFloat(value)\n        } else {\n            const integer = parseInt(value)\n            if (isNaN(integer)) {\n                return null\n            } else {\n                return integer\n            }\n        }\n    }\n}\n\nvar parse = function (csv, options) {\n    // cache settings\n    const separator = options.separator\n    const delimiter = options.delimiter\n\n    // set initial state if it's missing\n    if (!options.state.rowNum) {\n        options.state.rowNum = 1\n    }\n    if (!options.state.colNum) {\n        options.state.colNum = 1\n    }\n\n    // clear initial state\n    const data = []\n    let entry = []\n    let state = 0\n    let value = ''\n    let exit = false\n\n    function endOfEntry() {\n        // reset the state\n        state = 0\n        value = ''\n\n        // if 'start' hasn't been met, don't output\n        if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = []\n            options.state.rowNum++\n            options.state.colNum = 1\n            return\n        }\n\n        if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry)\n        } else {\n            const hookVal = options.onParseEntry(entry, options.state) // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n                data.push(hookVal)\n            }\n        }\n        // console.log('entry:' + entry);\n\n        // cleanup\n        entry = []\n\n        // if 'end' is met, stop parsing\n        if (options.end && options.state.rowNum >= options.end) {\n            exit = true\n        }\n\n        // update global state\n        options.state.rowNum++\n        options.state.colNum = 1\n    }\n\n    function endOfValue() {\n        if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value)\n        } else if (options.headers && options.state.rowNum === 1) {\n            // don't onParseValue object headers\n            entry.push(value)\n        } else {\n            const hook = options.onParseValue(value, options.state) // onParseValue Hook\n            // false skips the row, configurable through a hook\n            if (hook !== false) {\n                entry.push(hook)\n            }\n        }\n        // console.log('value:' + value);\n        // reset the state\n        value = ''\n        state = 0\n        // update global state\n        options.state.colNum++\n    }\n\n    // escape regex-specific control chars\n    const escSeparator = RegExp.escape(separator)\n    const escDelimiter = RegExp.escape(delimiter)\n\n    // compile the regEx str using the custom delimiter/separator\n    let match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/\n    let matchSrc = match.source\n    matchSrc = matchSrc.replace(/S/g, escSeparator)\n    matchSrc = matchSrc.replace(/D/g, escDelimiter)\n    match = new RegExp(matchSrc, 'gm')\n\n    // put on your fancy pants...\n    // process control chars individually, use look-ahead on non-control chars\n    csv.replace(match, function (m0) {\n        if (exit) {\n            return\n        }\n        switch (state) {\n            // the start of a value\n            case 0:\n                // null last value\n                if (m0 === separator) {\n                    value += ''\n                    endOfValue()\n                    break\n                }\n                // opening delimiter\n                if (m0 === delimiter) {\n                    state = 1\n                    break\n                }\n                // null last value\n                if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                    endOfValue()\n                    endOfEntry()\n                    break\n                }\n                // un-delimited value\n                value += m0\n                state = 3\n                break\n\n            // delimited input\n            case 1:\n                // second delimiter? check further\n                if (m0 === delimiter) {\n                    state = 2\n                    break\n                }\n                // delimited data\n                value += m0\n                state = 1\n                break\n\n            // delimiter found in delimited input\n            case 2:\n                // escaped delimiter?\n                if (m0 === delimiter) {\n                    value += m0\n                    state = 1\n                    break\n                }\n                // null value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // end of entry\n                if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                    endOfValue()\n                    endOfEntry()\n                    break\n                }\n                // broken paser?\n                throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n\n            // un-delimited input\n            case 3:\n                // null last value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // end of entry\n                if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                    endOfValue()\n                    endOfEntry()\n                    break\n                }\n                if (m0 === delimiter) {\n                    // non-compliant data\n                    throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n                }\n                // broken parser?\n                throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n            default:\n                // shenanigans\n                throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n        }\n        // console.log('val:' + m0 + ' state:' + state);\n    })\n\n    // submit the last entry\n    // ignore null last line\n    if (entry.length !== 0) {\n        endOfValue()\n        endOfEntry()\n    }\n\n    return data\n}\n\n// a csv-specific line splitter\nvar splitLines = function (csv, options) {\n    if (!csv) {\n        return undefined\n    }\n\n    options = options || {}\n\n    // cache settings\n    const separator = options.separator || $.csv.defaults.separator\n    const delimiter = options.delimiter || $.csv.defaults.delimiter\n\n    // set initial state if it's missing\n    options.state = options.state || {}\n    if (!options.state.rowNum) {\n        options.state.rowNum = 1\n    }\n\n    // clear initial state\n    const entries = []\n    let state = 0\n    let entry = ''\n    let exit = false\n\n    function endOfLine() {\n        // reset the state\n        state = 0\n\n        // if 'start' hasn't been met, don't output\n        if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = ''\n            options.state.rowNum++\n            return\n        }\n\n        if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry)\n        } else {\n            const hookVal = options.onParseEntry(entry, options.state) // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n                entries.push(hookVal)\n            }\n        }\n\n        // cleanup\n        entry = ''\n\n        // if 'end' is met, stop parsing\n        if (options.end && options.state.rowNum >= options.end) {\n            exit = true\n        }\n\n        // update global state\n        options.state.rowNum++\n    }\n\n    // escape regex-specific control chars\n    const escSeparator = RegExp.escape(separator)\n    const escDelimiter = RegExp.escape(delimiter)\n\n    // compile the regEx str using the custom delimiter/separator\n    let match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/\n    let matchSrc = match.source\n    matchSrc = matchSrc.replace(/S/g, escSeparator)\n    matchSrc = matchSrc.replace(/D/g, escDelimiter)\n    match = new RegExp(matchSrc, 'gm')\n\n    // put on your fancy pants...\n    // process control chars individually, use look-ahead on non-control chars\n    csv.replace(match, function (m0) {\n        if (exit) {\n            return\n        }\n        switch (state) {\n            // the start of a value/entry\n            case 0:\n                // null value\n                if (m0 === separator) {\n                    entry += m0\n                    state = 0\n                    break\n                }\n                // opening delimiter\n                if (m0 === delimiter) {\n                    entry += m0\n                    state = 1\n                    break\n                }\n                // end of line\n                if (m0 === '\\n') {\n                    endOfLine()\n                    break\n                }\n                // phantom carriage return\n                if (/^\\r$/.test(m0)) {\n                    break\n                }\n                // un-delimit value\n                entry += m0\n                state = 3\n                break\n\n            // delimited input\n            case 1:\n                // second delimiter? check further\n                if (m0 === delimiter) {\n                    entry += m0\n                    state = 2\n                    break\n                }\n                // delimited data\n                entry += m0\n                state = 1\n                break\n\n            // delimiter found in delimited input\n            case 2: {\n                // escaped delimiter?\n                const prevChar = entry.substr(entry.length - 1)\n                if (m0 === delimiter && prevChar === delimiter) {\n                    entry += m0\n                    state = 1\n                    break\n                }\n                // end of value\n                if (m0 === separator) {\n                    entry += m0\n                    state = 0\n                    break\n                }\n                // end of line\n                if (m0 === '\\n') {\n                    endOfLine()\n                    break\n                }\n                // phantom carriage return\n                if (m0 === '\\r') {\n                    break\n                }\n                // broken paser?\n                throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']')\n            }\n            // un-delimited input\n            case 3:\n                // null value\n                if (m0 === separator) {\n                    entry += m0\n                    state = 0\n                    break\n                }\n                // end of line\n                if (m0 === '\\n') {\n                    endOfLine()\n                    break\n                }\n                // phantom carriage return\n                if (m0 === '\\r') {\n                    break\n                }\n                // non-compliant data\n                if (m0 === delimiter) {\n                    throw Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']')\n                }\n                // broken parser?\n                throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']')\n            default:\n                // shenanigans\n                throw Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']')\n        }\n        // console.log('val:' + m0 + ' state:' + state);\n    })\n\n    // submit the last entry\n    // ignore null last line\n    if (entry !== '') {\n        endOfLine()\n    }\n\n    return entries\n}\n\n// a csv entry parser\nvar parseEntry = function (csv, options) {\n    // cache settings\n    const separator = options.separator\n    const delimiter = options.delimiter\n\n    // set initial state if it's missing\n    if (!options.state.rowNum) {\n        options.state.rowNum = 1\n    }\n    if (!options.state.colNum) {\n        options.state.colNum = 1\n    }\n\n    // clear initial state\n    const entry = []\n    let state = 0\n    let value = ''\n\n    function endOfValue() {\n        if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value)\n        } else {\n            const hook = options.onParseValue(value, options.state) // onParseValue Hook\n            // false skips the value, configurable through a hook\n            if (hook !== false) {\n                entry.push(hook)\n            }\n        }\n        // reset the state\n        value = ''\n        state = 0\n        // update global state\n        options.state.colNum++\n    }\n\n    // checked for a cached regEx first\n    if (!options.match) {\n        // escape regex-specific control chars\n        const escSeparator = RegExp.escape(separator)\n        const escDelimiter = RegExp.escape(delimiter)\n\n        // compile the regEx str using the custom delimiter/separator\n        const match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/\n        let matchSrc = match.source\n        matchSrc = matchSrc.replace(/S/g, escSeparator)\n        matchSrc = matchSrc.replace(/D/g, escDelimiter)\n        options.match = new RegExp(matchSrc, 'gm')\n    }\n\n    // put on your fancy pants...\n    // process control chars individually, use look-ahead on non-control chars\n    csv.replace(options.match, function (m0) {\n        switch (state) {\n            // the start of a value\n            case 0:\n                // null last value\n                if (m0 === separator) {\n                    value += ''\n                    endOfValue()\n                    break\n                }\n                // opening delimiter\n                if (m0 === delimiter) {\n                    state = 1\n                    break\n                }\n                // skip un-delimited new-lines\n                if (m0 === '\\n' || m0 === '\\r') {\n                    break\n                }\n                // un-delimited value\n                value += m0\n                state = 3\n                break\n\n            // delimited input\n            case 1:\n                // second delimiter? check further\n                if (m0 === delimiter) {\n                    state = 2\n                    break\n                }\n                // delimited data\n                value += m0\n                state = 1\n                break\n\n            // delimiter found in delimited input\n            case 2:\n                // escaped delimiter?\n                if (m0 === delimiter) {\n                    value += m0\n                    state = 1\n                    break\n                }\n                // null value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // skip un-delimited new-lines\n                if (m0 === '\\n' || m0 === '\\r') {\n                    break\n                }\n                // broken paser?\n                throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n\n            // un-delimited input\n            case 3:\n                // null last value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // skip un-delimited new-lines\n                if (m0 === '\\n' || m0 === '\\r') {\n                    break\n                }\n                // non-compliant data\n                if (m0 === delimiter) {\n                    throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n                }\n                // broken parser?\n                throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n            default:\n                // shenanigans\n                throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n        }\n        // console.log('val:' + m0 + ' state:' + state);\n    })\n\n    // submit the last value\n    endOfValue()\n\n    return entry\n}\n\n/**\n* $.csv.helpers.collectPropertyNames(objectsArray)\n* Collects all unique property names from all passed objects.\n*\n* @param {Array} objects Objects to collect properties from.\n*\n* Returns an array of property names (array will be empty,\n* if objects have no own properties).\n*/\nvar collectPropertyNames = function (objects) {\n    let o = []\n    let propName = []\n    const props = []\n    for (o in objects) {\n        for (propName in objects[o]) {\n            if ((objects[o].hasOwnProperty(propName)) &&\n                (props.indexOf(propName) < 0) &&\n                (typeof objects[o][propName] !== 'function')) {\n                props.push(propName)\n            }\n        }\n    }\n    return props\n}\n\n/**\n* $.csv.toArray(csv)\n* Converts a CSV entry string to a javascript array.\n*\n* @param {Array} csv The string containing the CSV data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n*\n* This method deals with simple CSV strings only. It's useful if you only\n* need to parse a single entry. If you need to parse more than one line,\n* use $.csv2Array instead.\n*/\nvar toArray = function (csv, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : defaults.delimiter\n    const state = (options.state !== undefined ? options.state : {})\n\n    // setup\n    options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n    }\n\n    const entry = parseEntry(csv, options)\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return entry\n    } else {\n        config.callback('', entry)\n    }\n}\n\n/**\n* $.csv.toArrays(csv)\n* Converts a CSV string to a javascript array.\n*\n* @param {String} csv The string containing the raw CSV data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n*\n* This method deals with multi-line CSV. The breakdown is simple. The first\n* dimension of the array represents the line (or entry/row) while the second\n* dimension contains the values (or values/columns).\n*/\nvar toArrays = function (csv, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n\n    // setup\n    let data = []\n    options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n            rowNum: 1,\n            colNum: 1\n        }\n    }\n\n    // onPreParse hook\n    if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state)\n    }\n\n    // parse the data\n    data = $.csv.parsers.parse(csv, options)\n\n    // onPostParse hook\n    if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state)\n    }\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return data\n    } else {\n        config.callback('', data)\n    }\n}\n\n/**\n* $.csv.toObjects(csv)\n* Converts a CSV string to a javascript object.\n* @param {String} csv The string containing the raw CSV data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n* @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n*\n* This method deals with multi-line CSV strings. Where the headers line is\n* used as the key for each value per entry.\n*/\nexport var csvToObjects = function (csv, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : defaults.delimiter\n    config.headers = 'headers' in options ? options.headers : defaults.headers\n    options.start = 'start' in options ? options.start : 1\n\n    // account for headers\n    if (config.headers) {\n        options.start++\n    }\n    if (options.end && config.headers) {\n        options.end++\n    }\n\n    // setup\n    let lines = []\n    let data = []\n\n    options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n            rowNum: 1,\n            colNum: 1\n        },\n        match: false,\n        transform: options.transform\n    }\n\n    // fetch the headers\n    const headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n            rowNum: 1,\n            colNum: 1\n        },\n        headers: true\n    }\n\n    // onPreParse hook\n    if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state)\n    }\n\n    // parse the csv\n    const headerLine = splitLines(csv, headerOptions)\n    const headers = toArray(headerLine[0], headerOptions)\n\n    // fetch the data\n    lines = splitLines(csv, options)\n\n    // reset the state for re-use\n    options.state.colNum = 1\n    if (headers) {\n        options.state.rowNum = 2\n    } else {\n        options.state.rowNum = 1\n    }\n\n    // convert data to objects\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const entry = toArray(lines[i], options)\n        const object = {}\n        for (let j = 0; j < headers.length; j++) {\n            object[headers[j]] = entry[j]\n        }\n        if (options.transform !== undefined) {\n            data.push(options.transform.call(undefined, object))\n        } else {\n            data.push(object)\n        }\n\n        // update row state\n        options.state.rowNum++\n    }\n\n    // onPostParse hook\n    if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state)\n    }\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return data\n    } else {\n        config.callback('', data)\n    }\n};\n\n/**\n* $.csv.fromArrays(arrays)\n* Converts a javascript array to a CSV String.\n*\n* @param {Array} arrays An array containing an array of CSV entries.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n*\n* This method generates a CSV file from an array of arrays (representing entries).\n*/\nvar fromArrays = function (arrays, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n\n    let output = ''\n\n    for (let i = 0; i < arrays.length; i++) {\n        const line = arrays[i]\n        const lineValues = []\n        for (let j = 0; j < line.length; j++) {\n            let strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString()\n            if (strValue.indexOf(config.delimiter) > -1) {\n                strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter)\n            }\n\n            let escMatcher = '\\n|\\r|S|D'\n            escMatcher = escMatcher.replace('S', config.separator)\n            escMatcher = escMatcher.replace('D', config.delimiter)\n\n            if (strValue.search(escMatcher) > -1) {\n                strValue = config.delimiter + strValue + config.delimiter\n            }\n            lineValues.push(strValue)\n        }\n        output += lineValues.join(config.separator) + '\\n'\n    }\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return output\n    } else {\n        config.callback('', output)\n    }\n}\n\n/**\n* $.csv.fromObjects(objects)\n* Converts a javascript dictionary to a CSV string.\n*\n* @param {Object} objects An array of objects containing the data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n* @param {Character} [sortOrder] Sort order of columns (named after\n*   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n*   which means, that properties will _probably_ appear in order they were\n*   declared for the object. But without any guarantee.\n* @param {Character or Array} [manualOrder] Manually order columns. May be\n* a strin in a same csv format as an output or an array of header names\n* (array items won't be parsed). All the properties, not present in\n* `manualOrder` will be appended to the end in accordance with `sortOrder`\n* option. So the `manualOrder` always takes preference, if present.\n*\n* This method generates a CSV file from an array of objects (name:value pairs).\n* It starts by detecting the headers and adding them as the first line of\n* the CSV file, followed by a structured dump of the data.\n*/\n\nvar fromObjects = function (objects, options, callback) {\n\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n    config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers\n    config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare'\n    config.manualOrder = 'manualOrder' in options ? options.manualOrder : []\n    config.transform = options.transform\n\n    if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config)\n    }\n\n    if (config.transform !== undefined) {\n        const origObjects = objects\n        objects = []\n\n        for (let i = 0; i < origObjects.length; i++) {\n            objects.push(config.transform.call(undefined, origObjects[i]))\n        }\n    }\n\n    let props = $.csv.helpers.collectPropertyNames(objects)\n\n    if (config.sortOrder === 'alpha') {\n        props.sort()\n    }\n\n    if (config.manualOrder.length > 0) {\n        const propsManual = [].concat(config.manualOrder)\n\n        for (let p = 0; p < props.length; p++) {\n            if (propsManual.indexOf(props[p]) < 0) {\n                propsManual.push(props[p])\n            }\n        }\n        props = propsManual\n    }\n\n    let line\n    const output = []\n    let propName\n    if (config.headers) {\n        output.push(props)\n    }\n\n    for (let o = 0; o < objects.length; o++) {\n        line = []\n        for (let p = 0; p < props.length; p++) {\n            propName = props[p]\n            if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n                line.push(objects[o][propName])\n            } else {\n                line.push('')\n            }\n        }\n        output.push(line)\n    }\n\n    // push the value to a callback if one is defined\n    return fromArrays(output, options, config.callback)\n}\n\n"],
  "mappings": "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",
  "names": []
}
